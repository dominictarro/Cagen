import random


def solution(x: int) -> bool:
	r = x**0.5
	if r.is_integer():
		if r <= 3:
			return r > 1
		elif (r % 2 == 0) | (r % 3 == 0):
			return 0

		for i in range(5, int(r**0.5)+1, 2):
			if r % i == 0:
				return 0
		return 1
	return 0


def tPrimeSieveRoot(A: (int, float), B: int) -> list:
	"""
	Returns a list of primes in the range [A**0.5, A**0.5]

	:param A: Lower bound for squares
	:param B: Upper bound for squares
	"""
	a_root = int(A ** 0.5)
	root = int(B ** 0.5)
	sieve = [True] * root
	sieve[:1] = [False] * 2

	# Eliminate evens
	sieve[4::2] = [False] * int(root / 2 - 1)

	# Search for odds
	for i in range(3, int(root**0.5) + 1, 2):
		if sieve[i]:
			sieve[2*i::i] = [False] * int(root / i - 1)

	if a_root % 2 == 0:
		# Return primes that are along even indices
		# e.g. a_root = 10
		# x = 2*i + a_root
		# List comp [2*i + a_root for i, x in enumerate(sieve[a_root::2])]
		# i   0  1  2  3 ...
		# x  10 12 14 16 ...
		# [i*2 + a_root for i, x in enumerate(sieve[a_root+1::2])]
		# i   0  1  2  3 ...
		# x  11 13 15 17 ...
		return [2*i + a_root for i, x in enumerate(sieve[a_root+1::2]) if x]
	# Return odd indexed primes
	return [i*2 + a_root for i, x in enumerate(sieve[a_root::2]) if x]


def generate(a, b, n):
	"""

	:param a: lower exponent bound
	:param b: upper exponent bound
	:param n: sample size
	:return: list of cases: index 0 is the argument and index 1 is the expected output
	"""
	A = 10**a
	if a == 0:
		A = 0
	B = 10**b

	# Take roots of bounds
	aroot = int(A**0.5)
	broot = int(B**0.5)

	sieve = tPrimeSieveRoot(A, B)

	tprime_n = int(n/3)
	# Take sample
	try:
		sieve_samp = random.sample(sieve, tprime_n)
	except ValueError:
		# If fewer primes in range than demanded, use all primes
		tprime_n = len(sieve)
		sieve_samp = sieve

	odd_n = int((n - tprime_n)/2)
	sieve_set = set(sieve)
	if a % 2 == 0:
		# Start on an odd index
		odd_samp = [(x**2, 0) for x in set(random.sample(range(aroot+1, broot, 2), odd_n)) - sieve_set]
		even_n = max(n - tprime_n - len(odd_samp), 0)
		# Start on an even index
		even_samp = [(x**2, 0) for x in random.sample(range(aroot, broot, 2), even_n)]
	else:
		# Start on an odd index
		odd_samp = [(x**2, 0) for x in set(random.sample(range(aroot, broot, 2), odd_n)) - sieve_set]
		# Start on an even index
		even_samp = [(x**2, 0) for x in random.sample(range(aroot+1, broot, 2), n - tprime_n - len(odd_samp))]


	# Join
	cases = []
	cases.extend(odd_samp)
	cases.extend(even_samp)
	cases.extend([(x**2, 1) for x in sieve_samp])
	random.shuffle(cases)

	try:
		# See if (4, 0) was generated by the even sample
		# If so, convert to correct case
		i = cases.index((4, 0))
		cases[i] = (4, 1)
	except ValueError:
		pass

	# Add some mixers
	for x in range(int(n-n**0.5)):
		if A+x not in sieve:
			i = random.randint(0, n-1)
			cases[i] = (A+x, 0)
		if abs(B-x) not in sieve:
			i = random.randint(0, n-1)
			cases[i] = (B+x, 0)


	for i, x in enumerate(cases):
		arg, answer = x
		sol = solution(arg)
		if sol != answer:
			cases[i] = (arg, sol)
	return cases
